//! Block API handlers.

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use strom_types::api::ErrorResponse;
use strom_types::block::{
    BlockCategoriesResponse, BlockDefinition, BlockListResponse, BlockResponse, CreateBlockRequest,
};
use tracing::info;

use crate::state::AppState;

/// List all block definitions (built-in + user-defined).
#[utoipa::path(
    get,
    path = "/api/blocks",
    tag = "blocks",
    responses(
        (status = 200, description = "List all blocks", body = BlockListResponse)
    )
)]
pub async fn list_blocks(State(state): State<AppState>) -> Json<BlockListResponse> {
    let blocks = state.blocks().get_all().await;
    Json(BlockListResponse { blocks })
}

/// Get a specific block definition by ID.
#[utoipa::path(
    get,
    path = "/api/blocks/{id}",
    tag = "blocks",
    params(
        ("id" = String, Path, description = "Block ID")
    ),
    responses(
        (status = 200, description = "Block found", body = BlockResponse),
        (status = 404, description = "Block not found", body = ErrorResponse)
    )
)]
pub async fn get_block(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<Json<BlockResponse>, (StatusCode, Json<ErrorResponse>)> {
    match state.blocks().get_by_id(&id).await {
        Some(block) => Ok(Json(BlockResponse { block })),
        None => Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse::new("Block not found")),
        )),
    }
}

/// Create a new user-defined block.
#[utoipa::path(
    post,
    path = "/api/blocks",
    tag = "blocks",
    request_body = CreateBlockRequest,
    responses(
        (status = 201, description = "Block created", body = BlockResponse),
        (status = 400, description = "Bad request", body = ErrorResponse),
        (status = 500, description = "Internal server error", body = ErrorResponse)
    )
)]
pub async fn create_block(
    State(state): State<AppState>,
    Json(req): Json<CreateBlockRequest>,
) -> Result<(StatusCode, Json<BlockResponse>), (StatusCode, Json<ErrorResponse>)> {
    info!("Creating new block: {}", req.name);

    let block = BlockDefinition {
        id: String::new(), // Will be generated by registry
        name: req.name,
        description: req.description,
        category: req.category,
        exposed_properties: req.exposed_properties,
        external_pads: req.external_pads,
        built_in: false,
        ui_metadata: req.ui_metadata,
    };

    match state.blocks().add_user_block(block).await {
        Ok(()) => {
            // Retrieve the newly created block (with generated ID)
            let all_blocks = state.blocks().get_all().await;
            if let Some(created_block) = all_blocks.last() {
                Ok((
                    StatusCode::CREATED,
                    Json(BlockResponse {
                        block: created_block.clone(),
                    }),
                ))
            } else {
                Err((
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(ErrorResponse::new("Failed to retrieve created block")),
                ))
            }
        }
        Err(e) => Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse::with_details("Failed to create block", e)),
        )),
    }
}

/// Update an existing user-defined block.
#[utoipa::path(
    put,
    path = "/api/blocks/{id}",
    tag = "blocks",
    params(
        ("id" = String, Path, description = "Block ID")
    ),
    request_body = BlockDefinition,
    responses(
        (status = 200, description = "Block updated", body = BlockResponse),
        (status = 400, description = "Bad request", body = ErrorResponse),
        (status = 404, description = "Block not found", body = ErrorResponse),
        (status = 500, description = "Internal server error", body = ErrorResponse)
    )
)]
pub async fn update_block(
    State(state): State<AppState>,
    Path(id): Path<String>,
    Json(block): Json<BlockDefinition>,
) -> Result<Json<BlockResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Ensure ID matches
    if id != block.id {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse::new("Block ID mismatch")),
        ));
    }

    // Check if block exists
    if state.blocks().get_by_id(&id).await.is_none() {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse::new("Block not found")),
        ));
    }

    info!("Updating block: {} ({})", block.name, block.id);

    match state.blocks().update_user_block(block.clone()).await {
        Ok(()) => Ok(Json(BlockResponse { block })),
        Err(e) => Err((
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse::with_details("Failed to update block", e)),
        )),
    }
}

/// Delete a user-defined block.
#[utoipa::path(
    delete,
    path = "/api/blocks/{id}",
    tag = "blocks",
    params(
        ("id" = String, Path, description = "Block ID")
    ),
    responses(
        (status = 204, description = "Block deleted"),
        (status = 400, description = "Bad request", body = ErrorResponse),
        (status = 404, description = "Block not found", body = ErrorResponse),
        (status = 500, description = "Internal server error", body = ErrorResponse)
    )
)]
pub async fn delete_block(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    match state.blocks().delete_user_block(&id).await {
        Ok(true) => {
            info!("Deleted block: {}", id);
            Ok(StatusCode::NO_CONTENT)
        }
        Ok(false) => Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse::new("Block not found")),
        )),
        Err(e) => Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse::with_details("Failed to delete block", e)),
        )),
    }
}

/// Get all block categories.
#[utoipa::path(
    get,
    path = "/api/blocks/categories",
    tag = "blocks",
    responses(
        (status = 200, description = "List of block categories", body = BlockCategoriesResponse)
    )
)]
pub async fn get_categories(State(state): State<AppState>) -> Json<BlockCategoriesResponse> {
    let categories = state.blocks().get_categories().await;
    Json(BlockCategoriesResponse { categories })
}
