//! SDP (Session Description Protocol) generation for AES67 blocks.
//!
//! Implements RFC 7273 clock signaling for AES67 streams:
//! - ts-refclk: indicates the reference clock (PTP, NTP, or local)
//! - mediaclk: indicates media clock relationship to reference clock

use gstreamer as gst;
use strom_types::flow::{FlowProperties, GStreamerClockType};
use strom_types::{BlockInstance, PropertyValue};

/// Extract audio format details from GStreamer caps.
/// Returns (sample_rate, channels) or None if the caps don't contain audio info.
pub fn parse_audio_caps(caps: &gst::Caps) -> Option<(i32, i32)> {
    // Get the first structure from the caps
    let structure = caps.structure(0)?;

    // Check if it's audio caps
    let name = structure.name();
    if !name.starts_with("audio/") {
        return None;
    }

    // Extract sample rate (field name is "rate")
    let sample_rate = structure.get::<i32>("rate").ok()?;

    // Extract channels
    let channels = structure.get::<i32>("channels").ok()?;

    Some((sample_rate, channels))
}

/// Generate the ts-refclk attribute based on flow clock configuration.
///
/// Per RFC 7273:
/// - PTP: `a=ts-refclk:ptp=IEEE1588-2008:<clock-identity>:<domain>`
/// - NTP: `a=ts-refclk:ntp=<server>` or `a=ts-refclk:ntp=/traceable/`
/// - Local/other: `a=ts-refclk:local`
///
/// The `ptp_clock_identity` parameter is optional - if not provided for PTP,
/// a placeholder identity will be used.
pub fn generate_ts_refclk(
    flow_properties: Option<&FlowProperties>,
    ptp_clock_identity: Option<&str>,
) -> String {
    let props = match flow_properties {
        Some(p) => p,
        None => {
            // Default to local sender clock when no properties specified
            return "a=ts-refclk:local".to_string();
        }
    };

    match props.clock_type {
        GStreamerClockType::Ptp => {
            let domain = props.ptp_domain.unwrap_or(0);
            // Use provided clock identity or placeholder
            // Clock identity format: XX-XX-XX-FF-FE-XX-XX-XX (8 bytes, hyphen-separated)
            let identity = ptp_clock_identity.unwrap_or("00-00-00-FF-FE-00-00-00");
            format!("a=ts-refclk:ptp=IEEE1588-2008:{}:{}", identity, domain)
        }
        GStreamerClockType::Ntp => {
            // Use specific NTP server if configured, otherwise use traceable
            match &props.ntp_server {
                Some(server) => format!("a=ts-refclk:ntp={}", server),
                None => "a=ts-refclk:ntp=/traceable/".to_string(),
            }
        }
        GStreamerClockType::Monotonic | GStreamerClockType::Realtime => {
            // For system clocks, use local sender reference
            "a=ts-refclk:local".to_string()
        }
    }
}

/// Generate the mediaclk attribute based on flow clock configuration.
///
/// Per RFC 7273:
/// - `direct=0`: Media clock is directly related to the reference clock with zero offset.
///   Used when the pipeline is synchronized to PTP or NTP.
/// - `sender`: Media clock is asynchronously generated by the sender.
///   Used for local/system clocks (Monotonic, Realtime) where there's no external sync.
///
/// For synchronized clocks (PTP/NTP), we use `direct=0` because:
/// - Pipeline base_time is set to 0
/// - Pipeline start_time is set to 0/None
/// - RTP payloader timestamp-offset is set to 0
///
/// For local clocks, we use `sender` to indicate the media clock is free-running.
pub fn generate_mediaclk(flow_properties: Option<&FlowProperties>) -> String {
    let props = match flow_properties {
        Some(p) => p,
        None => {
            // Default to sender (asynchronous) when no properties specified
            return "a=mediaclk:sender".to_string();
        }
    };

    match props.clock_type {
        GStreamerClockType::Ptp | GStreamerClockType::Ntp => {
            // Synchronized clocks: direct relationship to reference clock
            "a=mediaclk:direct=0".to_string()
        }
        GStreamerClockType::Monotonic | GStreamerClockType::Realtime => {
            // Local clocks: asynchronously generated by sender
            "a=mediaclk:sender".to_string()
        }
    }
}

/// Check if an IP address is multicast (224.0.0.0 to 239.255.255.255).
fn is_multicast_address(addr: &str) -> bool {
    // Try to parse as IPv4 address
    let parts: Vec<&str> = addr.split('.').collect();
    if parts.len() != 4 {
        return false;
    }

    // Parse first octet
    if let Ok(first_octet) = parts[0].parse::<u8>() {
        // Multicast range is 224-239 (class D)
        (224..=239).contains(&first_octet)
    } else {
        false
    }
}

/// Generate SDP for an AES67 output block instance.
///
/// The SDP describes the RTP stream parameters that receivers need to connect.
/// Uses configured block properties for accurate stream description.
///
/// # Clock Signaling (RFC 7273)
///
/// The `flow_properties` parameter controls clock signaling in the SDP:
///
/// Reference clock (ts-refclk):
/// - PTP clock: `a=ts-refclk:ptp=IEEE1588-2008:<identity>:<domain>`
/// - NTP clock: `a=ts-refclk:ntp=<server>` or `a=ts-refclk:ntp=/traceable/`
/// - Local/system clock: `a=ts-refclk:local`
///
/// Media clock (mediaclk):
/// - PTP/NTP (synchronized): `a=mediaclk:direct=0` - timestamps directly map to reference clock
/// - Monotonic/Realtime (local): `a=mediaclk:sender` - asynchronously generated by sender
///
/// The `ptp_clock_identity` parameter can provide the actual PTP clock identity
/// for accurate signaling when using PTP.
pub fn generate_aes67_output_sdp(
    block: &BlockInstance,
    session_name: &str,
    sample_rate: Option<i32>,
    channels: Option<i32>,
    flow_properties: Option<&FlowProperties>,
    ptp_clock_identity: Option<&str>,
) -> String {
    // Extract properties or use defaults
    let host = block
        .properties
        .get("host")
        .and_then(|v| {
            if let PropertyValue::String(s) = v {
                Some(s.as_str())
            } else {
                None
            }
        })
        .unwrap_or("239.69.1.1");

    let port = block
        .properties
        .get("port")
        .and_then(|v| {
            if let PropertyValue::Int(i) = v {
                Some(*i)
            } else {
                None
            }
        })
        .unwrap_or(5004);

    // Get bit depth to determine L16 vs L24
    let bit_depth = block
        .properties
        .get("bit_depth")
        .and_then(|v| match v {
            PropertyValue::Int(i) => Some(*i as i32),
            PropertyValue::String(s) => s.parse::<i32>().ok(),
            _ => None,
        })
        .unwrap_or(24);

    // Get packet time (ptime) in milliseconds
    let ptime = block
        .properties
        .get("ptime")
        .and_then(|v| match v {
            PropertyValue::Float(f) => Some(*f),
            PropertyValue::String(s) => s.parse::<f64>().ok(),
            _ => None,
        })
        .unwrap_or(1.0);

    // Get local IP for origin field (o=)
    // In a real implementation, you'd detect the actual network interface IP
    let origin_ip = "127.0.0.1";

    // Session ID and version (using timestamp)
    let session_id = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs();

    // Use provided values or fall back to AES67 defaults: 48kHz, 2 channels
    let sample_rate = sample_rate.unwrap_or(48000);
    let channels = channels.unwrap_or(2);
    let payload_type = 96; // Dynamic payload type

    // Determine encoding name based on bit depth
    let encoding = match bit_depth {
        16 => "L16",
        24 => "L24",
        _ => "L24", // Default to 24-bit
    };

    // Check if the host is a multicast address and format connection line accordingly
    // Multicast IPv4 addresses are in range 224.0.0.0 to 239.255.255.255
    let connection_line = if is_multicast_address(host) {
        format!("c=IN IP4 {}/32", host) // Add TTL for multicast
    } else {
        format!("c=IN IP4 {}", host) // No TTL for unicast
    };

    // Generate clock signaling attributes per RFC 7273
    let ts_refclk = generate_ts_refclk(flow_properties, ptp_clock_identity);
    let mediaclk = generate_mediaclk(flow_properties);

    // Generate SDP
    format!(
        "v=0\r
o=- {} {} IN IP4 {}\r
s={}\r
{}\r
t=0 0\r
a=recvonly\r
m=audio {} RTP/AVP {}\r
a=rtpmap:{} {}/{}/{}\r
a=ptime:{}\r
{}\r
{}\r
",
        session_id,
        session_id,
        origin_ip,
        session_name,
        connection_line,
        port,
        payload_type,
        payload_type,
        encoding,
        sample_rate,
        channels,
        ptime,
        ts_refclk,
        mediaclk
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    #[test]
    fn test_parse_audio_caps_44100_mono() {
        gst::init().unwrap();

        // Create caps for 44.1kHz mono audio (audiotestsrc default)
        let caps = gst::Caps::builder("audio/x-raw")
            .field("rate", 44100i32)
            .field("channels", 1i32)
            .build();

        let result = parse_audio_caps(&caps);
        assert_eq!(result, Some((44100, 1)));
    }

    #[test]
    fn test_parse_audio_caps_48000_stereo() {
        gst::init().unwrap();

        // Create caps for 48kHz stereo (AES67 standard)
        let caps = gst::Caps::builder("audio/x-raw")
            .field("rate", 48000i32)
            .field("channels", 2i32)
            .build();

        let result = parse_audio_caps(&caps);
        assert_eq!(result, Some((48000, 2)));
    }

    #[test]
    fn test_parse_audio_caps_non_audio() {
        gst::init().unwrap();

        // Create video caps - should return None
        let caps = gst::Caps::builder("video/x-raw")
            .field("width", 1920i32)
            .field("height", 1080i32)
            .build();

        let result = parse_audio_caps(&caps);
        assert_eq!(result, None);
    }

    #[test]
    fn test_generate_sdp_default_values() {
        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties: HashMap::new(),
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        let sdp = generate_aes67_output_sdp(&block, "Test Stream", None, None, None, None);

        assert!(sdp.contains("s=Test Stream"));
        assert!(sdp.contains("c=IN IP4 239.69.1.1/32")); // Multicast should have /32 TTL
        assert!(sdp.contains("m=audio 5004 RTP/AVP 96"));
        assert!(sdp.contains("a=rtpmap:96 L24/48000/2"));
        // Default clock signaling (no flow properties) should use local/sender
        assert!(sdp.contains("a=ts-refclk:local"));
        assert!(sdp.contains("a=mediaclk:sender"));
    }

    #[test]
    fn test_generate_sdp_custom_values() {
        let mut properties = HashMap::new();
        properties.insert(
            "host".to_string(),
            PropertyValue::String("239.1.2.3".to_string()),
        );
        properties.insert("port".to_string(), PropertyValue::Int(6000));

        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties,
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        let sdp = generate_aes67_output_sdp(&block, "Custom Stream", None, None, None, None);

        assert!(sdp.contains("s=Custom Stream"));
        assert!(sdp.contains("c=IN IP4 239.1.2.3/32")); // Multicast should have /32 TTL
        assert!(sdp.contains("m=audio 6000 RTP/AVP 96"));
    }

    #[test]
    fn test_generate_sdp_with_44100_mono() {
        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties: HashMap::new(),
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        // Test with audiotestsrc defaults: 44.1kHz mono
        let sdp =
            generate_aes67_output_sdp(&block, "Test Stream", Some(44100), Some(1), None, None);

        assert!(sdp.contains("s=Test Stream"));
        assert!(sdp.contains("a=rtpmap:96 L24/44100/1"));
    }

    #[test]
    fn test_generate_sdp_with_string_bit_depth_16() {
        let mut properties = HashMap::new();
        properties.insert(
            "bit_depth".to_string(),
            PropertyValue::String("16".to_string()),
        );

        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties,
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        let sdp = generate_aes67_output_sdp(&block, "Test Stream", None, None, None, None);

        // Should use L16 encoding, not L24
        assert!(sdp.contains("a=rtpmap:96 L16/48000/2"));
        assert!(!sdp.contains("L24"));
    }

    #[test]
    fn test_generate_sdp_with_string_bit_depth_24() {
        let mut properties = HashMap::new();
        properties.insert(
            "bit_depth".to_string(),
            PropertyValue::String("24".to_string()),
        );

        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties,
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        let sdp = generate_aes67_output_sdp(&block, "Test Stream", None, None, None, None);

        // Should use L24 encoding
        assert!(sdp.contains("a=rtpmap:96 L24/48000/2"));
    }

    #[test]
    fn test_generate_sdp_with_string_ptime() {
        let mut properties = HashMap::new();
        properties.insert(
            "ptime".to_string(),
            PropertyValue::String("4.0".to_string()),
        );

        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties,
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        let sdp = generate_aes67_output_sdp(&block, "Test Stream", None, None, None, None);

        // Should have ptime=4.0, not 1.0
        assert!(sdp.contains("a=ptime:4"));
        assert!(!sdp.contains("a=ptime:1"));
    }

    #[test]
    fn test_generate_sdp_with_all_string_properties() {
        let mut properties = HashMap::new();
        properties.insert(
            "bit_depth".to_string(),
            PropertyValue::String("16".to_string()),
        );
        properties.insert(
            "sample_rate".to_string(),
            PropertyValue::String("96000".to_string()),
        );
        properties.insert(
            "ptime".to_string(),
            PropertyValue::String("0.125".to_string()),
        );
        properties.insert("channels".to_string(), PropertyValue::Int(8));
        properties.insert(
            "host".to_string(),
            PropertyValue::String("239.1.2.3".to_string()),
        );
        properties.insert("port".to_string(), PropertyValue::Int(5008));

        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties,
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        let sdp = generate_aes67_output_sdp(
            &block,
            "Multi-channel Stream",
            Some(96000),
            Some(8),
            None,
            None,
        );

        // Verify all properties are correctly reflected in SDP
        assert!(sdp.contains("s=Multi-channel Stream"));
        assert!(sdp.contains("c=IN IP4 239.1.2.3/32")); // Multicast should have /32 TTL
        assert!(sdp.contains("m=audio 5008 RTP/AVP 96"));
        assert!(sdp.contains("a=rtpmap:96 L16/96000/8")); // L16 for 16-bit
        assert!(sdp.contains("a=ptime:0.125")); // 0.125 ms ptime
    }

    #[test]
    fn test_multicast_address_detection() {
        // Test multicast addresses (224.0.0.0 to 239.255.255.255)
        assert!(is_multicast_address("224.0.0.0"));
        assert!(is_multicast_address("239.255.255.255"));
        assert!(is_multicast_address("239.69.11.44"));
        assert!(is_multicast_address("225.1.2.3"));

        // Test non-multicast addresses
        assert!(!is_multicast_address("127.0.0.1"));
        assert!(!is_multicast_address("192.168.1.1"));
        assert!(!is_multicast_address("10.0.0.1"));
        assert!(!is_multicast_address("223.255.255.255")); // Just below multicast range
        assert!(!is_multicast_address("240.0.0.0")); // Just above multicast range

        // Test invalid addresses
        assert!(!is_multicast_address("invalid"));
        assert!(!is_multicast_address("999.999.999.999"));
        assert!(!is_multicast_address(""));
    }

    #[test]
    fn test_generate_sdp_unicast_no_ttl() {
        let mut properties = HashMap::new();
        properties.insert(
            "host".to_string(),
            PropertyValue::String("192.168.1.100".to_string()),
        );

        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties,
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        let sdp = generate_aes67_output_sdp(&block, "Unicast Stream", None, None, None, None);

        // Unicast addresses should NOT have /TTL suffix
        assert!(sdp.contains("c=IN IP4 192.168.1.100\r"));
        assert!(!sdp.contains("/32"));
    }

    #[test]
    fn test_generate_sdp_multicast_has_ttl() {
        let mut properties = HashMap::new();
        properties.insert(
            "host".to_string(),
            PropertyValue::String("239.69.11.44".to_string()),
        );

        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties,
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        let sdp = generate_aes67_output_sdp(&block, "Multicast Stream", None, None, None, None);

        // Multicast addresses MUST have /32 TTL suffix
        assert!(sdp.contains("c=IN IP4 239.69.11.44/32\r"));
    }

    // RFC 7273 clock signaling tests

    #[test]
    fn test_ts_refclk_ptp() {
        let props = FlowProperties {
            clock_type: GStreamerClockType::Ptp,
            ptp_domain: Some(42),
            ..Default::default()
        };

        let ts_refclk = generate_ts_refclk(Some(&props), Some("AA-BB-CC-FF-FE-DD-EE-FF"));
        assert_eq!(
            ts_refclk,
            "a=ts-refclk:ptp=IEEE1588-2008:AA-BB-CC-FF-FE-DD-EE-FF:42"
        );
    }

    #[test]
    fn test_ts_refclk_ptp_default_domain() {
        let props = FlowProperties {
            clock_type: GStreamerClockType::Ptp,
            ptp_domain: None,
            ..Default::default()
        };

        let ts_refclk = generate_ts_refclk(Some(&props), None);
        assert_eq!(
            ts_refclk,
            "a=ts-refclk:ptp=IEEE1588-2008:00-00-00-FF-FE-00-00-00:0"
        );
    }

    #[test]
    fn test_ts_refclk_ntp_with_server() {
        let props = FlowProperties {
            clock_type: GStreamerClockType::Ntp,
            ntp_server: Some("ntp.example.com".to_string()),
            ..Default::default()
        };

        let ts_refclk = generate_ts_refclk(Some(&props), None);
        assert_eq!(ts_refclk, "a=ts-refclk:ntp=ntp.example.com");
    }

    #[test]
    fn test_ts_refclk_ntp_traceable() {
        let props = FlowProperties {
            clock_type: GStreamerClockType::Ntp,
            ntp_server: None,
            ..Default::default()
        };

        let ts_refclk = generate_ts_refclk(Some(&props), None);
        assert_eq!(ts_refclk, "a=ts-refclk:ntp=/traceable/");
    }

    #[test]
    fn test_ts_refclk_local() {
        let props = FlowProperties {
            clock_type: GStreamerClockType::Monotonic,
            ..Default::default()
        };

        let ts_refclk = generate_ts_refclk(Some(&props), None);
        assert_eq!(ts_refclk, "a=ts-refclk:local");
    }

    #[test]
    fn test_ts_refclk_no_properties() {
        let ts_refclk = generate_ts_refclk(None, None);
        assert_eq!(ts_refclk, "a=ts-refclk:local");
    }

    #[test]
    fn test_mediaclk_ptp() {
        let props = FlowProperties {
            clock_type: GStreamerClockType::Ptp,
            ..Default::default()
        };
        let mediaclk = generate_mediaclk(Some(&props));
        assert_eq!(mediaclk, "a=mediaclk:direct=0");
    }

    #[test]
    fn test_mediaclk_ntp() {
        let props = FlowProperties {
            clock_type: GStreamerClockType::Ntp,
            ..Default::default()
        };
        let mediaclk = generate_mediaclk(Some(&props));
        assert_eq!(mediaclk, "a=mediaclk:direct=0");
    }

    #[test]
    fn test_mediaclk_monotonic() {
        let props = FlowProperties {
            clock_type: GStreamerClockType::Monotonic,
            ..Default::default()
        };
        let mediaclk = generate_mediaclk(Some(&props));
        assert_eq!(mediaclk, "a=mediaclk:sender");
    }

    #[test]
    fn test_mediaclk_realtime() {
        let props = FlowProperties {
            clock_type: GStreamerClockType::Realtime,
            ..Default::default()
        };
        let mediaclk = generate_mediaclk(Some(&props));
        assert_eq!(mediaclk, "a=mediaclk:sender");
    }

    #[test]
    fn test_mediaclk_no_properties() {
        let mediaclk = generate_mediaclk(None);
        assert_eq!(mediaclk, "a=mediaclk:sender");
    }

    #[test]
    fn test_generate_sdp_with_ptp_clock() {
        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties: HashMap::new(),
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        let flow_props = FlowProperties {
            clock_type: GStreamerClockType::Ptp,
            ptp_domain: Some(127),
            ..Default::default()
        };

        let sdp = generate_aes67_output_sdp(
            &block,
            "PTP Stream",
            None,
            None,
            Some(&flow_props),
            Some("12-34-56-FF-FE-78-9A-BC"),
        );

        assert!(sdp.contains("a=ts-refclk:ptp=IEEE1588-2008:12-34-56-FF-FE-78-9A-BC:127"));
        assert!(sdp.contains("a=mediaclk:direct=0"));
    }

    #[test]
    fn test_generate_sdp_with_ntp_clock() {
        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties: HashMap::new(),
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        let flow_props = FlowProperties {
            clock_type: GStreamerClockType::Ntp,
            ntp_server: Some("time.google.com".to_string()),
            ..Default::default()
        };

        let sdp =
            generate_aes67_output_sdp(&block, "NTP Stream", None, None, Some(&flow_props), None);

        assert!(sdp.contains("a=ts-refclk:ntp=time.google.com"));
        assert!(sdp.contains("a=mediaclk:direct=0"));
    }

    #[test]
    fn test_generate_sdp_with_monotonic_clock() {
        let block = BlockInstance {
            id: "block_0".to_string(),
            block_definition_id: "builtin.aes67_output".to_string(),
            name: None,
            properties: HashMap::new(),
            position: strom_types::block::Position { x: 0.0, y: 0.0 },
            runtime_data: None,
        };

        let flow_props = FlowProperties {
            clock_type: GStreamerClockType::Monotonic,
            ..Default::default()
        };

        let sdp =
            generate_aes67_output_sdp(&block, "Local Stream", None, None, Some(&flow_props), None);

        // Monotonic clock uses local reference and sender media clock
        assert!(sdp.contains("a=ts-refclk:local"));
        assert!(sdp.contains("a=mediaclk:sender"));
    }
}
