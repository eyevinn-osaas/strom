<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WHEP Player - Strom</title>
    <link rel="stylesheet" href="/static/whep.css">
</head>
<body style="display: flex; flex-direction: column; align-items: center;">
    <div class="container">
        <div style="text-align: right; margin-bottom: 8px;">
            <a href="/player/whep-streams" style="color: #888; font-size: 0.9em;">All streams â†’</a>
        </div>
        <h1 style="text-align: center;">WHEP Player at <span id="hostAddress"></span></h1>

        <div class="form-group">
            <label for="endpoint">WHEP Endpoint URL</label>
            <input type="text" id="endpoint" placeholder="/whep/my-stream" value="{{ENDPOINT}}">
        </div>

        <div class="form-group" id="fullUrlGroup" style="display: none;">
            <label>Full WHEP URL (for external players)</label>
            <div style="display: flex; gap: 8px;">
                <input type="text" id="fullUrl" readonly style="flex: 1; background: #252525; cursor: text;">
                <button onclick="copyFullUrl()" style="white-space: nowrap;">Copy URL</button>
            </div>
        </div>

        <div style="display: flex; gap: 8px; margin-bottom: 16px;">
            <button class="connect-btn" id="connectBtn" style="flex: 1;" onclick="doConnect()">Connect</button>
            <button class="disconnect-btn" id="disconnectBtn" style="flex: 1;" onclick="doDisconnect()" disabled>Disconnect</button>
        </div>

        <div style="display: flex; flex-direction: column; align-items: center; gap: 12px; width: 100%;">
            <div class="video-container" id="videoContainer" style="max-width: 720px;">
                <video id="video" autoplay muted playsinline controls></video>
            </div>
            <div class="audio-indicator" id="audioIndicator">
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
            </div>
            <div class="audio-controls" id="audioControls" style="width: 100%; max-width: 400px;">
                <button class="mute-btn" id="muteBtn" onclick="toggleMute()" title="Toggle mute">&#128266;</button>
                <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="100" oninput="setVolume(this.value)">
                <span class="volume-label" id="volumeLabel">100%</span>
            </div>
        </div>

        <div class="status disconnected" id="status" style="margin-top: 16px;">Not connected</div>

        <div class="log" id="log"></div>
    </div>

    <audio id="audio" autoplay></audio>

    <script src="/static/whep.js"></script>
    <script>
        let connection = null;
        let connectionId = 0;       // Incremented each connect to ignore stale callbacks
        let wantConnected = false;  // User's intent: should we be connected?
        let reconnectAttempt = 0;
        let reconnectTimer = null;
        const MAX_RECONNECT_ATTEMPTS = 15;
        const RECONNECT_DELAYS = [1000, 2000, 3000, 5000, 5000, 10000, 15000, 30000]; // Backoff delays in ms

        function log(message, type = '') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = new Date().toLocaleTimeString() + ' - ' + message;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function getReconnectDelay() {
            const idx = Math.min(reconnectAttempt, RECONNECT_DELAYS.length - 1);
            return RECONNECT_DELAYS[idx];
        }

        function scheduleReconnect(reason) {
            // Prevent double scheduling or scheduling when not wanted
            if (!wantConnected || reconnectTimer) return;

            // Check max attempts
            if (reconnectAttempt >= MAX_RECONNECT_ATTEMPTS) {
                log('Max reconnection attempts (' + MAX_RECONNECT_ATTEMPTS + ') reached. Giving up.', 'error');
                setStatus('status', 'Connection failed - click Connect to retry', 'error');
                wantConnected = false;
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;
                return;
            }

            const delay = getReconnectDelay();
            reconnectAttempt++;
            log('Reconnecting in ' + (delay/1000) + 's (attempt ' + reconnectAttempt + '/' + MAX_RECONNECT_ATTEMPTS + ')... Reason: ' + reason, 'warning');
            setStatus('status', 'Reconnecting in ' + (delay/1000) + 's (attempt ' + reconnectAttempt + ')...', 'connecting');

            reconnectTimer = setTimeout(() => {
                reconnectTimer = null;
                if (wantConnected) {
                    doConnect(true); // true = is reconnect attempt
                }
            }, delay);
        }

        function cancelReconnect() {
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }
        }

        function doConnect(isReconnect = false) {
            const endpoint = document.getElementById('endpoint').value.trim();
            if (!endpoint) {
                log('Please enter a WHEP endpoint URL', 'error');
                return;
            }

            cancelReconnect();
            wantConnected = true;

            // Increment connection ID - any callbacks from old connections will be ignored
            connectionId++;
            const myConnectionId = connectionId;

            // Clean up existing connection without triggering our callbacks
            if (connection) {
                // Clear callbacks before disconnect to prevent them from firing
                connection.callbacks = {};
                connection.close();
                connection = null;
            }

            document.getElementById('connectBtn').disabled = true;
            document.getElementById('disconnectBtn').disabled = false;
            setStatus('status', isReconnect ? 'Reconnecting...' : 'Connecting...', 'connecting');
            log(isReconnect ? 'Reconnecting to ' + endpoint : 'Connecting to ' + endpoint);

            connection = new WhepConnection(endpoint, {
                onAudioTrack: (stream) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    document.getElementById('audio').srcObject = stream;
                },
                onVideoTrack: (stream) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    const video = document.getElementById('video');
                    video.srcObject = stream;
                    setElementClass('videoContainer', 'active', true);
                    // Start playback muted (allowed by browsers)
                    // User can unmute via video controls
                    video.muted = true;
                    video.play().catch(e => {
                        log('Autoplay blocked: ' + e.message, 'warning');
                    });
                },
                onConnected: () => {
                    if (myConnectionId !== connectionId) return; // Stale
                    cancelReconnect(); // Cancel any pending reconnect timer!
                    reconnectAttempt = 0; // Reset on successful connection
                    document.getElementById('disconnectBtn').disabled = false;
                    setStatus('status', 'Connected - Waiting for media...', 'connected');
                    log('Connected successfully', 'success');
                },
                onMediaStatus: (hasAudio, hasVideo) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    let mediaTypes = [];
                    if (hasAudio) mediaTypes.push('audio');
                    if (hasVideo) mediaTypes.push('video');
                    if (mediaTypes.length > 0) {
                        setStatus('status', 'Connected - Playing ' + mediaTypes.join(' + '), 'connected');
                    }
                    // Show audio indicator if stream has audio (regardless of video)
                    // Show audio controls only for audio-only streams (video has its own controls)
                    const isAudioOnly = hasAudio && !hasVideo;
                    setElementClass('audioIndicator', 'active', hasAudio);
                    setElementClass('audioControls', 'active', isAudioOnly);
                },
                onError: (msg) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    log('Error: ' + msg, 'error');
                    setStatus('status', 'Connection failed: ' + msg, 'error');
                    document.getElementById('connectBtn').disabled = false;
                    // Schedule reconnect on error if user wants to be connected
                    if (wantConnected) {
                        scheduleReconnect('error: ' + msg);
                    }
                },
                onDisconnected: () => {
                    if (myConnectionId !== connectionId) return; // Stale

                    setElementClass('audioIndicator', 'active', false);
                    setElementClass('audioControls', 'active', false);
                    setElementClass('videoContainer', 'active', false);
                    document.getElementById('audio').srcObject = null;
                    document.getElementById('video').srcObject = null;
                    document.getElementById('connectBtn').disabled = false;

                    // Auto-reconnect if user wants to stay connected
                    if (wantConnected) {
                        scheduleReconnect('connection lost');
                    } else {
                        setStatus('status', 'Disconnected', 'disconnected');
                        document.getElementById('disconnectBtn').disabled = true;
                    }
                },
                onIceState: (state) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    log('ICE state: ' + state);
                },
                onLog: (msg, type) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    log(msg, type || '');
                }
            });

            connection.connect();
        }

        function doDisconnect() {
            wantConnected = false;
            cancelReconnect();
            reconnectAttempt = 0;
            connectionId++; // Invalidate any pending callbacks
            log('Disconnecting...');
            if (connection) {
                connection.disconnect();
                connection = null;
            }
            setStatus('status', 'Disconnected', 'disconnected');
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            log('Disconnected', 'success');
        }

        function updateFullUrl() {
            const endpoint = document.getElementById('endpoint').value.trim();
            const fullUrlGroup = document.getElementById('fullUrlGroup');
            const fullUrlInput = document.getElementById('fullUrl');
            if (endpoint) {
                const fullUrl = window.location.protocol + '//' + window.location.host + endpoint;
                fullUrlInput.value = fullUrl;
                fullUrlGroup.style.display = 'block';
            } else {
                fullUrlGroup.style.display = 'none';
            }
        }

        function copyFullUrl() {
            const fullUrl = document.getElementById('fullUrl').value;
            navigator.clipboard.writeText(fullUrl).then(() => {
                log('Copied URL to clipboard', 'success');
            });
        }

        function toggleMute() {
            const audio = document.getElementById('audio');
            const muteBtn = document.getElementById('muteBtn');
            audio.muted = !audio.muted;
            if (audio.muted) {
                muteBtn.innerHTML = '&#128263;'; // Muted speaker
                muteBtn.classList.add('muted');
            } else {
                muteBtn.innerHTML = '&#128266;'; // Speaker with sound
                muteBtn.classList.remove('muted');
            }
        }

        function setVolume(value) {
            const audio = document.getElementById('audio');
            const volumeLabel = document.getElementById('volumeLabel');
            const muteBtn = document.getElementById('muteBtn');
            audio.volume = value / 100;
            volumeLabel.textContent = value + '%';
            // Update mute button state based on volume
            if (value == 0) {
                muteBtn.innerHTML = '&#128263;';
                muteBtn.classList.add('muted');
            } else if (!audio.muted) {
                muteBtn.innerHTML = '&#128266;';
                muteBtn.classList.remove('muted');
            }
        }

        // Update full URL when endpoint changes
        document.getElementById('endpoint').addEventListener('input', updateFullUrl);

        // Auto-connect if endpoint is provided
        window.onload = () => {
            document.getElementById('hostAddress').textContent = location.host;
            document.title = 'WHEP Player | Strom | ' + location.host;
            updateFullUrl();
            const endpoint = document.getElementById('endpoint').value;
            if (endpoint) {
                wantConnected = true;
                setTimeout(() => doConnect(false), 500);
            }
        };
    </script>
</body>
</html>
