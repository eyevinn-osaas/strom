<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.85">
    <title>WHEP Player - Strom</title>
    <link rel="stylesheet" href="/static/webrtc.css">
    <link rel="stylesheet" href="/static/whep.css">
</head>
<body style="display: flex; flex-direction: column; align-items: center;">
    <div class="container">
        <div style="position: relative; margin-bottom: 8px;">
            <span style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); color: #666; font-size: 0.7em;">v5</span>
            <h1 style="text-align: center; margin: 0;">WHEP Player at <span id="hostAddress"></span></h1>
            <a href="/player/whep-streams" style="color: #888; font-size: 0.9em; position: absolute; right: 0; top: 50%; transform: translateY(-50%);">All streams</a>
        </div>

        <div class="form-group">
            <label for="endpoint">WHEP Endpoint URL</label>
            <div style="display: flex; gap: 8px;">
                <input type="text" id="endpoint" placeholder="http://localhost:8081/whep/my-stream" value="" style="flex: 1;">
                <button onclick="copyEndpointUrl()" style="white-space: nowrap;">Copy URL</button>
            </div>
        </div>

        <div style="display: flex; gap: 8px; margin-bottom: 16px;">
            <button class="connect-btn" id="connectBtn" style="flex: 1;" onclick="doConnect()">Connect</button>
            <button class="disconnect-btn" id="disconnectBtn" style="flex: 1;" onclick="doDisconnect()" disabled>Disconnect</button>
        </div>

        <div style="display: flex; flex-direction: column; align-items: center; gap: 12px; width: 100%;">
            <div class="video-container" id="videoContainer" style="max-width: 720px;">
                <video id="video" autoplay muted playsinline controls></video>
            </div>
            <div class="audio-indicator" id="audioIndicator">
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
            </div>
            <div class="audio-controls" id="audioControls" style="width: 100%; max-width: 400px;">
                <button class="mute-btn" id="muteBtn" onclick="toggleMute()" title="Toggle mute">&#128266;</button>
                <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="100" oninput="setVolume(this.value)">
                <span class="volume-label" id="volumeLabel">100%</span>
            </div>
            <div id="audioOutputGroup" style="display: none; width: 100%; max-width: 400px;">
                <label style="color: #888; font-size: 12px;">Output:
                    <select id="audioOutputSelect" style="width: auto; padding: 4px 8px;" onchange="onAudioOutputChange()"></select>
                </label>
            </div>
        </div>

        <div class="status disconnected" id="status" style="margin-top: 16px;">Not connected</div>

        <div style="display: flex; align-items: center; gap: 6px; margin-top: 16px; margin-bottom: 4px;">
            <input type="checkbox" id="debugMode" data-storage-key="whep-debug" onchange="toggleDebugMode(); whepDebugMode = this.checked;" style="margin: 0; width: auto;">
            <label for="debugMode" style="color: #666; font-size: 0.8em; cursor: pointer; margin: 0;">Debug</label>
            <button onclick="copyLog()" style="padding: 2px 6px; white-space: nowrap;">Copy log</button>
        </div>
        <div class="log" id="log"></div>
    </div>

    <audio id="audio" autoplay></audio>

    <script src="/static/webrtc.js"></script>
    <script src="/static/whep.js"></script>
    <script src="/static/devices.js"></script>
    <script>
        let connection = null;
        let connectionId = 0;       // Incremented each connect to ignore stale callbacks
        let wantConnected = false;  // User's intent: should we be connected?
        let reconnectAttempt = 0;
        let reconnectTimer = null;
        let transportSuffix = '';   // Debug: " - relay <addr>" or " - direct <addr>"
        let hasAudioStream = false;
        const MAX_RECONNECT_ATTEMPTS = 15;
        const RECONNECT_DELAY = 10000;

        // Device management (audio output selection)
        const deviceManager = new DeviceManager({
            storagePrefix: 'whep',
            onLog: (msg, type) => log(msg, type),
            onDevicesChanged: updateAudioOutputDropdown
        });

        function updateAudioOutputDropdown() {
            const group = document.getElementById('audioOutputGroup');
            const select = document.getElementById('audioOutputSelect');
            const showDropdown = hasAudioStream && deviceManager.populateAudioOutputSelect(select);
            group.style.display = showDropdown ? 'block' : 'none';
        }

        async function onAudioOutputChange() {
            const deviceId = document.getElementById('audioOutputSelect').value;
            if (!deviceId) return;
            const audio = document.getElementById('audio');
            const video = document.getElementById('video');
            const ok = await deviceManager.setAudioOutput(deviceId, audio, video);
            if (ok) log('Switched audio output');
        }

        function scheduleReconnect(reason) {
            // Prevent double scheduling or scheduling when not wanted
            if (!wantConnected || reconnectTimer) return;

            // Check max attempts
            if (reconnectAttempt >= MAX_RECONNECT_ATTEMPTS) {
                log('Max reconnection attempts (' + MAX_RECONNECT_ATTEMPTS + ') reached. Giving up.', 'error');
                setStatus('status', 'Connection failed - click Connect to retry', 'error');
                wantConnected = false;
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;
                return;
            }

            const delay = RECONNECT_DELAY;
            reconnectAttempt++;
            log('Reconnecting in ' + (delay/1000) + 's (attempt ' + reconnectAttempt + '/' + MAX_RECONNECT_ATTEMPTS + ')... Reason: ' + reason, 'warning');
            setStatus('status', 'Reconnecting in ' + (delay/1000) + 's (attempt ' + reconnectAttempt + ')...', 'connecting');

            reconnectTimer = setTimeout(() => {
                reconnectTimer = null;
                if (wantConnected) {
                    doConnect(true); // true = is reconnect attempt
                }
            }, delay);
        }

        function cancelReconnect() {
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }
        }

        function doConnect(isReconnect = false) {
            const endpoint = document.getElementById('endpoint').value.trim();
            if (!endpoint) {
                log('Please enter a WHEP endpoint URL', 'error');
                return;
            }

            cancelReconnect();
            wantConnected = true;

            // Increment connection ID - any callbacks from old connections will be ignored
            connectionId++;
            const myConnectionId = connectionId;

            // Clean up existing connection without triggering our callbacks
            if (connection) {
                // Clear callbacks before disconnect to prevent them from firing
                connection.callbacks = {};
                connection.close();
                connection = null;
            }

            document.getElementById('connectBtn').disabled = true;
            document.getElementById('disconnectBtn').disabled = false;
            setStatus('status', isReconnect ? 'Reconnecting...' : 'Connecting...', 'connecting');
            log(isReconnect ? 'Reconnecting to ' + endpoint : 'Connecting to ' + endpoint);

            connection = new WhepConnection(endpoint, {
                onAudioTrack: (stream) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    document.getElementById('audio').srcObject = stream;
                },
                onVideoTrack: (stream) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    const video = document.getElementById('video');
                    video.srcObject = stream;
                    setElementClass('videoContainer', 'active', true);
                    // Start playback muted (allowed by browsers)
                    // User can unmute via video controls
                    video.muted = true;
                    video.play().catch(e => {
                        log('Autoplay blocked: ' + e.message, 'warning');
                    });
                },
                onConnected: async () => {
                    if (myConnectionId !== connectionId) return; // Stale
                    cancelReconnect(); // Cancel any pending reconnect timer!
                    reconnectAttempt = 0; // Reset on successful connection
                    document.getElementById('disconnectBtn').disabled = false;
                    transportSuffix = '';
                    setStatus('status', 'Connected', 'connected');
                    // Delay transport info check — ICE connects with the first
                    // successful pair (often relay) then promotes a better direct
                    // pair. Wait 2s so ICE has time to settle on the final pair.
                    if (whepDebugMode && connection) {
                        setTimeout(async () => {
                            if (myConnectionId !== connectionId || !connection) return;
                            const info = await connection.getTransportInfo();
                            if (info) {
                                const via = info.type === 'relay' ? 'relay' : 'direct';
                                transportSuffix = ' - ' + via + (info.remoteAddress ? ' ' + info.remoteAddress : '');
                                log('Transport: ' + via + ' (' + info.protocol + ')' +
                                    (info.remoteAddress ? ' to ' + info.remoteAddress : '') +
                                    (info.relayProtocol ? ' via ' + info.relayProtocol : ''), 'success');
                                setStatus('status', 'Connected' + transportSuffix, 'connected');
                            }
                        }, 2000);
                    }
                    log('Connected successfully', 'success');
                },
                onMediaStatus: (hasAudio, hasVideo) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    // Show audio indicator if stream has audio (regardless of video)
                    // Show audio controls only for audio-only streams (video has its own controls)
                    const isAudioOnly = hasAudio && !hasVideo;
                    setElementClass('audioIndicator', 'active', hasAudio);
                    setElementClass('audioControls', 'active', isAudioOnly);
                    hasAudioStream = hasAudio;
                    // Re-enumerate devices now that we have an active media
                    // session — browsers restrict enumerateDevices until media
                    // is flowing, so the initial enumeration may have returned
                    // only the default device.
                    deviceManager.enumerate();
                },
                onError: (msg) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    log('Error: ' + msg, 'error');
                    setStatus('status', 'Connection failed: ' + msg, 'error');
                    document.getElementById('connectBtn').disabled = false;
                    // Schedule reconnect on error if user wants to be connected
                    if (wantConnected) {
                        scheduleReconnect('error: ' + msg);
                    }
                },
                onDisconnected: () => {
                    if (myConnectionId !== connectionId) return; // Stale

                    setElementClass('audioIndicator', 'active', false);
                    setElementClass('audioControls', 'active', false);
                    setElementClass('videoContainer', 'active', false);
                    hasAudioStream = false;
                    updateAudioOutputDropdown();
                    document.getElementById('audio').srcObject = null;
                    document.getElementById('video').srcObject = null;
                    document.getElementById('connectBtn').disabled = false;

                    // Auto-reconnect if user wants to stay connected
                    if (wantConnected) {
                        scheduleReconnect('connection lost');
                    } else {
                        setStatus('status', 'Disconnected', 'disconnected');
                        document.getElementById('disconnectBtn').disabled = true;
                    }
                },
                onIceState: (state) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    // Only log ICE state in debug mode
                    if (document.getElementById('debugMode').checked) {
                        log('ICE state: ' + state);
                    }
                },
                onLog: (msg, type) => {
                    if (myConnectionId !== connectionId) return; // Stale
                    log(msg, type || '');
                }
            });

            connection.connect();
        }

        function doDisconnect() {
            wantConnected = false;
            cancelReconnect();
            reconnectAttempt = 0;
            connectionId++; // Invalidate any pending callbacks
            log('Disconnecting...');
            if (connection) {
                connection.disconnect();
                connection = null;
            }
            // Clean up UI (onDisconnected callback won't fire - stale connectionId)
            setElementClass('audioIndicator', 'active', false);
            setElementClass('audioControls', 'active', false);
            setElementClass('videoContainer', 'active', false);
            hasAudioStream = false;
            updateAudioOutputDropdown();
            document.getElementById('audio').srcObject = null;
            document.getElementById('video').srcObject = null;
            setStatus('status', 'Disconnected', 'disconnected');
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            log('Disconnected', 'success');
        }

        function copyEndpointUrl() {
            const url = document.getElementById('endpoint').value.trim();
            if (!url) { log('No URL to copy', 'error'); return; }
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(url).then(() => {
                    log('Copied URL to clipboard', 'success');
                }).catch(() => copyFallback(url));
            } else {
                copyFallback(url);
            }
        }

        function toggleMute() {
            const audio = document.getElementById('audio');
            const muteBtn = document.getElementById('muteBtn');
            audio.muted = !audio.muted;
            if (audio.muted) {
                muteBtn.innerHTML = '&#128263;'; // Muted speaker
                muteBtn.classList.add('muted');
            } else {
                muteBtn.innerHTML = '&#128266;'; // Speaker with sound
                muteBtn.classList.remove('muted');
            }
        }

        function setVolume(value) {
            const audio = document.getElementById('audio');
            const volumeLabel = document.getElementById('volumeLabel');
            const muteBtn = document.getElementById('muteBtn');
            audio.volume = value / 100;
            volumeLabel.textContent = value + '%';
            // Update mute button state based on volume
            if (value == 0) {
                muteBtn.innerHTML = '&#128263;';
                muteBtn.classList.add('muted');
            } else if (!audio.muted) {
                muteBtn.innerHTML = '&#128266;';
                muteBtn.classList.remove('muted');
            }
        }

        // Auto-connect if endpoint is provided
        window.onload = () => {
            document.getElementById('hostAddress').textContent = location.host;
            document.title = 'WHEP Player | Strom | ' + location.host;
            // Restore debug mode from previous session
            const debugRestored = restoreDebugMode('whep-debug');
            if (debugRestored) setWhepDebugMode(true);
            // Enumerate audio output devices
            deviceManager.enumerate();
            // Set endpoint from server-provided value
            const serverEndpoint = '{{ENDPOINT}}';
            if (serverEndpoint) {
                document.getElementById('endpoint').value = location.protocol + '//' + location.host + serverEndpoint;
            }

            // Auto-test mode: ?autotest=1
            // Loops: connect -> verify stream -> disconnect -> wait -> reconnect -> verify -> repeat
            const params = new URLSearchParams(window.location.search);
            if (params.get('autotest') === '1') {
                // Enable debug mode for log relay during autotest
                const debugCheckbox = document.getElementById('debugMode');
                if (debugCheckbox) { debugCheckbox.checked = true; whepDebugMode = true; }

                let cycle = 0;
                let passCount = 0;
                let failCount = 0;

                function autotestConnect() {
                    // Clean up any existing connection
                    if (connection) {
                        connection.callbacks = {};
                        connection.close();
                        connection = null;
                    }
                    cancelReconnect();

                    return new Promise((resolve) => {
                        let settled = false;
                        const settle = (result) => {
                            if (!settled) { settled = true; resolve(result); }
                        };

                        connectionId++;
                        const myId = connectionId;
                        const endpoint = document.getElementById('endpoint').value.trim();

                        connection = new WhepConnection(endpoint, {
                            onAudioTrack: (stream) => {
                                if (myId !== connectionId) return;
                                document.getElementById('audio').srcObject = stream;
                            },
                            onVideoTrack: (stream) => {
                                if (myId !== connectionId) return;
                                document.getElementById('video').srcObject = stream;
                            },
                            onConnected: () => {
                                if (myId !== connectionId) return;
                                settle('connected');
                            },
                            onMediaStatus: () => {},
                            onError: (msg) => {
                                if (myId !== connectionId) return;
                                settle('error: ' + msg);
                            },
                            onDisconnected: () => {
                                if (myId !== connectionId) return;
                                settle('disconnected');
                            },
                            onIceState: () => {},
                            onLog: (msg, type) => {
                                if (myId !== connectionId) return;
                                log(msg, type || '');
                            }
                        });
                        connection.connect();

                        // Timeout
                        setTimeout(() => settle('timeout'), 30000);
                    });
                }

                function autotestDisconnect() {
                    cancelReconnect();
                    wantConnected = false;
                    connectionId++;
                    if (connection) {
                        connection.callbacks = {};
                        connection.disconnect();
                        connection = null;
                    }
                }

                async function runAutoTestCycle() {
                    cycle++;
                    log('=== WHEP AUTOTEST cycle ' + cycle + ': connect -> disconnect -> reconnect ===', 'warning');
                    wantConnected = false;

                    // Phase 1: Connect
                    log('AUTOTEST [' + cycle + ']: Connect', 'warning');
                    let result = await autotestConnect();
                    log('AUTOTEST [' + cycle + ']: Connect result: ' + result);
                    if (result !== 'connected') {
                        log('AUTOTEST [' + cycle + ']: Initial connect failed (' + result + '), retrying cycle', 'error');
                        failCount++;
                        autotestDisconnect();
                        await new Promise(r => setTimeout(r, 5000));
                        runAutoTestCycle();
                        return;
                    }

                    // Stay connected 10s to verify stability
                    await new Promise(r => setTimeout(r, 10000));
                    if (!connection || !connection.isConnected()) {
                        log('AUTOTEST [' + cycle + ']: Connection dropped during stability check', 'error');
                        failCount++;
                        autotestDisconnect();
                        await new Promise(r => setTimeout(r, 5000));
                        runAutoTestCycle();
                        return;
                    }

                    // Phase 2: Disconnect
                    log('AUTOTEST [' + cycle + ']: Disconnect', 'warning');
                    autotestDisconnect();
                    await new Promise(r => setTimeout(r, 4000));

                    // Phase 3: Reconnect
                    log('AUTOTEST [' + cycle + ']: Reconnect', 'warning');
                    result = await autotestConnect();
                    const ok = result === 'connected';
                    if (ok) passCount++; else failCount++;
                    log('AUTOTEST [' + cycle + ']: ' + (ok ? 'PASS' : 'FAIL (' + result + ')') +
                        ' [total: ' + passCount + ' pass, ' + failCount + ' fail]',
                        ok ? 'success' : 'error');

                    // Clean disconnect
                    autotestDisconnect();
                    await new Promise(r => setTimeout(r, 4000));
                    runAutoTestCycle();
                }

                // Start after a short delay
                if (serverEndpoint) {
                    setTimeout(() => runAutoTestCycle(), 2000);
                } else {
                    log('AUTOTEST: No endpoint configured', 'error');
                }
            } else if (serverEndpoint) {
                // Normal auto-connect
                wantConnected = true;
                setTimeout(() => doConnect(false), 500);
            }
        };
    </script>
</body>
</html>
